#!/usr/bin/env python3
"""
huv - Hierarchical UV Virtual Environment Manager

A wrapper around uv to create hierarchical virtual environments where child environments
can inherit packages from parent environments with proper precedence handling.

Features:
- Create hierarchical virtual environments with automatic inheritance
- Smart pip install that skips packages available from parent environments
- pip uninstall with visibility into what remains available from parents
- Full compatibility with uv and standard virtual environments

Usage:
    huv venv <path> [--parent <parent_path>] [other uv options]
    huv pip install <packages...>
    huv pip uninstall <packages...>
    huv --help

Version: 0.3.0
"""

import argparse
import json
import os
import re
import subprocess
import sys
from pathlib import Path


class HierarchicalUV:
    def __init__(self):
        self.uv_executable = self._find_uv()
        self.current_venv = self._get_current_venv()

    def _find_uv(self):
        """Find the uv executable in PATH"""
        import shutil

        uv_path = shutil.which("uv")
        if not uv_path:
            print(
                "Error: 'uv' not found in PATH. Please install uv first.",
                file=sys.stderr,
            )
            print(
                "Install with: curl -LsSf https://astral.sh/uv/install.sh | sh",
                file=sys.stderr,
            )
            sys.exit(1)
        return uv_path

    def _get_python_version(self, venv_path):
        """Extract Python version from pyvenv.cfg file"""
        pyvenv_cfg = Path(venv_path) / "pyvenv.cfg"
        if not pyvenv_cfg.exists():
            return None

        try:
            with open(pyvenv_cfg) as f:
                for line in f:
                    if line.startswith("version_info ="):
                        # Extract version like "3.12.10" and return just "3.12"
                        version_str = line.split("=", 1)[1].strip()
                        version_parts = version_str.split(".")
                        if len(version_parts) >= 2:
                            return f"{version_parts[0]}.{version_parts[1]}"
        except OSError:
            pass

        return None

    def create_venv(self, venv_path, parent_path=None, uv_args=None):
        """Create a virtual environment with optional parent hierarchy"""
        venv_path = Path(venv_path).resolve()

        # Check if target already exists
        if venv_path.exists():
            if (venv_path / "pyvenv.cfg").exists():
                print(
                    f"Error: Virtual environment already exists at '{venv_path}'",
                    file=sys.stderr,
                )
                sys.exit(1)
            elif any(venv_path.iterdir()):
                print(
                    f"Error: Directory '{venv_path}' exists and is not empty",
                    file=sys.stderr,
                )
                sys.exit(1)

        # Validate parent environment if specified
        if parent_path:
            parent_path = Path(parent_path).resolve()
            if not parent_path.exists():
                print(
                    f"Error: Parent environment '{parent_path}' does not exist.",
                    file=sys.stderr,
                )
                sys.exit(1)
            if not (parent_path / "pyvenv.cfg").exists():
                print(
                    f"Error: '{parent_path}' is not a valid virtual environment.",
                    file=sys.stderr,
                )
                sys.exit(1)
            if not (parent_path / "bin" / "activate").exists():
                print(
                    f"Error: Parent environment '{parent_path}' is missing activate script.",
                    file=sys.stderr,
                )
                sys.exit(1)

            # Validate Python version compatibility with parent
            parent_python_version = self._get_python_version(parent_path)
            if parent_python_version:
                # Check if specific Python version requested via uv args
                requested_python_version = None
                python_specified = False
                if uv_args:
                    for i, arg in enumerate(uv_args):
                        if arg == "--python" and i + 1 < len(uv_args):
                            python_specified = True
                            python_arg = uv_args[i + 1]
                            # Extract version from python executable path or version string
                            version_match = re.search(r"(\d+\.\d+)", python_arg)
                            if version_match:
                                requested_python_version = version_match.group(1)
                            break

                # If a specific Python version was requested, validate compatibility
                if (
                    requested_python_version
                    and requested_python_version != parent_python_version
                ):
                    print(
                        f"Error: Child environment Python version ({requested_python_version}) "
                        f"must match parent environment Python version ({parent_python_version}) "
                        f"for package compatibility.",
                        file=sys.stderr,
                    )
                    sys.exit(1)

                # If no Python version specified, automatically use parent's version
                if not python_specified:
                    if uv_args is None:
                        uv_args = []
                    uv_args.extend(["--python", parent_python_version])
                    print(f"Using parent's Python version: {parent_python_version}")

        # Build uv command
        cmd = [self.uv_executable, "venv", str(venv_path)]
        if uv_args:
            cmd.extend(uv_args)

        print(f"Creating virtual environment: {venv_path}")
        if parent_path:
            print(f"Parent environment: {parent_path}")

        try:
            subprocess.run(cmd, check=True)
        except subprocess.CalledProcessError as e:
            print(f"Error creating virtual environment: {e}", file=sys.stderr)
            sys.exit(1)

        # Verify the environment was created successfully
        if not (venv_path / "bin" / "activate").exists():
            print(
                "Error: Virtual environment creation failed - missing activate script",
                file=sys.stderr,
            )
            sys.exit(1)

        # If parent is specified, modify activation scripts
        if parent_path:
            print(f"Setting up hierarchy with parent: {parent_path}")
            try:
                self._setup_hierarchy(venv_path, parent_path)
            except Exception as e:
                print(f"Error setting up hierarchy: {e}", file=sys.stderr)
                print(
                    "Virtual environment created but hierarchy setup failed.",
                    file=sys.stderr,
                )
                sys.exit(1)

        print(f"âœ“ Virtual environment created successfully at: {venv_path}")
        if parent_path:
            print(f"âœ“ Hierarchy configured with parent: {parent_path}")
            print(f"  Use: source {venv_path}/bin/activate")

    def _setup_hierarchy(self, venv_path, parent_path):
        """Modify activation scripts to support hierarchy"""
        self._modify_bash_activate(venv_path, parent_path)
        self._modify_activate_this_py(venv_path, parent_path)

    def _modify_bash_activate(self, venv_path, parent_path):
        """Modify the bash activate script"""
        activate_script = venv_path / "bin" / "activate"

        if not activate_script.exists():
            print(f"Warning: Activate script not found at {activate_script}")
            return

        # Read the original script
        with open(activate_script) as f:
            content = f.read()

        # Find the deactivate function and add PYTHONPATH restoration
        deactivate_insertion = """    if ! [ -z "${_OLD_VIRTUAL_PYTHONHOME+_}" ] ; then
        PYTHONHOME="$_OLD_VIRTUAL_PYTHONHOME"
        export PYTHONHOME
        unset _OLD_VIRTUAL_PYTHONHOME
    fi
    if ! [ -z "${_OLD_VIRTUAL_PYTHONPATH+_}" ] ; then
        PYTHONPATH="$_OLD_VIRTUAL_PYTHONPATH"
        export PYTHONPATH
        unset _OLD_VIRTUAL_PYTHONPATH
    elif [ ! -z "${PYTHONPATH+_}" ] ; then
        unset PYTHONPATH
    fi"""

        # Replace the PYTHONHOME section in deactivate function
        old_pythonhome_section = """    if ! [ -z "${_OLD_VIRTUAL_PYTHONHOME+_}" ] ; then
        PYTHONHOME="$_OLD_VIRTUAL_PYTHONHOME"
        export PYTHONHOME
        unset _OLD_VIRTUAL_PYTHONHOME
    fi"""

        content = content.replace(old_pythonhome_section, deactivate_insertion)

        # Add hierarchical support at the end
        hierarchy_code = f'''
# Hierarchical environment support - include parent libraries
PARENT_VENV_PATH="{parent_path}"
if [ -d "$PARENT_VENV_PATH" ]; then
    # Store old PYTHONPATH
    if ! [ -z "${{PYTHONPATH+_}}" ] ; then
        _OLD_VIRTUAL_PYTHONPATH="$PYTHONPATH"
    fi

    # Add parent site-packages to PYTHONPATH (appended, so child takes precedence)
    # Use find to locate site-packages directories to avoid shell glob issues
    for parent_site in "$PARENT_VENV_PATH"/lib/python*/site-packages; do
        if [ -d "$parent_site" ]; then
            if [ -z "${{PYTHONPATH+_}}" ]; then
                PYTHONPATH="$parent_site"
            else
                PYTHONPATH="$PYTHONPATH:$parent_site"
            fi
        fi
    done
    if [ ! -z "${{PYTHONPATH+_}}" ]; then
        export PYTHONPATH
    fi
fi

'''

        # Insert before the final hash command
        hash_line = "hash -r 2>/dev/null || true"
        content = content.replace(hash_line, hierarchy_code + hash_line)

        # Write the modified script
        with open(activate_script, "w") as f:
            f.write(content)

    def _modify_activate_this_py(self, venv_path, parent_path):
        """Modify the activate_this.py script"""
        activate_this = venv_path / "bin" / "activate_this.py"

        if not activate_this.exists():
            print(f"Warning: activate_this.py not found at {activate_this}")
            return

        # Read the original script
        with open(activate_this) as f:
            content = f.read()

        # Find the sys.path modification section (more flexible matching)
        old_pattern = (
            r"# add the virtual environments libraries.*?sys\.path\[:] = .*?\n"
        )

        # Create the new hierarchical version
        new_syspath_section = f'''# add the virtual environments libraries to the host python import mechanism
import glob
prev_length = len(sys.path)

# Add child environment libraries first (highest precedence)
child_lib_pattern = os.path.join(bin_dir, "..", "lib", "python*", "site-packages")
for child_site_packages in glob.glob(child_lib_pattern):
    if os.path.exists(child_site_packages):
        site.addsitedir(child_site_packages)

# Add parent environment libraries (lower precedence)
parent_venv_path = "{parent_path}"
if os.path.exists(parent_venv_path):
    parent_lib_pattern = os.path.join(parent_venv_path, "lib", "python*", "site-packages")
    for parent_site_packages in glob.glob(parent_lib_pattern):
        if os.path.exists(parent_site_packages):
            site.addsitedir(parent_site_packages)

# Move new paths to front for proper precedence (child first, then parent)
new_paths = sys.path[prev_length:]
sys.path[prev_length:] = []
sys.path[:0] = new_paths
'''

        # Replace the section using regex
        content = re.sub(old_pattern, new_syspath_section, content, flags=re.DOTALL)

        # Write the modified script
        with open(activate_this, "w") as f:
            f.write(content)

    def _get_current_venv(self):
        """Get the current virtual environment path"""
        venv_path = os.environ.get("VIRTUAL_ENV")
        if venv_path:
            return Path(venv_path)
        return None

    def _find_parent_venv(self, venv_path):
        """Find the parent virtual environment for a given venv"""
        if not venv_path:
            return None

        activate_script = venv_path / "bin" / "activate"
        if not activate_script.exists():
            return None

        try:
            with open(activate_script) as f:
                content = f.read()
                # Look for the PARENT_VENV_PATH line
                match = re.search(r'PARENT_VENV_PATH="([^"]*)"', content)
                if match:
                    parent_path = match.group(1)
                    if parent_path and Path(parent_path).exists():
                        return Path(parent_path)
        except Exception:
            pass
        return None

    def _get_installed_packages(self, venv_path):
        """Get installed packages in a virtual environment"""
        if not venv_path or not venv_path.exists():
            return {}

        python_exe = venv_path / "bin" / "python"
        if not python_exe.exists():
            return {}

        # Try uv pip first, then fall back to regular pip
        for pip_cmd in [
            [self.uv_executable, "pip", "list", "--format=json"],
            [str(python_exe), "-m", "pip", "list", "--format=json"],
        ]:
            try:
                # Set VIRTUAL_ENV for uv pip to work correctly
                env = os.environ.copy()
                env["VIRTUAL_ENV"] = str(venv_path)

                result = subprocess.run(
                    pip_cmd, capture_output=True, text=True, check=True, env=env
                )

                packages = {}
                for pkg in json.loads(result.stdout):
                    packages[pkg["name"].lower()] = pkg["version"]
                return packages
            except Exception:
                continue

        return {}

    def _get_parent_packages(self, venv_path):
        """Get all packages available from parent environments"""
        all_packages = {}
        current = venv_path

        while current:
            parent = self._find_parent_venv(current)
            if not parent:
                break

            parent_packages = self._get_installed_packages(parent)
            # Add packages that aren't already in our collection (child takes precedence)
            for pkg_name, version in parent_packages.items():
                if pkg_name not in all_packages:
                    all_packages[pkg_name] = version

            current = parent

        return all_packages

    def _get_dependency_tree(self, packages, pip_args=None):
        """Get the full dependency tree for packages using dry-run"""
        cmd = [self.uv_executable, "pip", "install", "--dry-run"] + packages
        if pip_args:
            cmd.extend(pip_args)

        try:
            # Temporarily remove PYTHONPATH to get accurate dependency analysis
            # This prevents uv from seeing parent packages as "already installed"
            env = os.environ.copy()
            env.pop("PYTHONPATH", None)

            result = subprocess.run(
                cmd, capture_output=True, text=True, check=True, env=env
            )

            # Parse the dry-run output to extract package names and versions
            dependencies = {}

            # uv output format: "Would install X packages" followed by " + package==version" lines
            lines = result.stdout.split("\n") + result.stderr.split("\n")

            for line in lines:
                line = line.strip()
                # Look for lines like " + package==version"
                if line.startswith("+") and "==" in line:
                    pkg_info = line[1:].strip()  # Remove "+"
                    if "==" in pkg_info:
                        pkg_name, version = pkg_info.split("==", 1)
                        dependencies[pkg_name.lower()] = version

            return dependencies
        except subprocess.CalledProcessError:
            # If dry-run fails, fall back to the original approach
            return {}

    def _parse_version_constraint(self, pkg_spec):
        """Parse package specification to extract name and version constraint"""
        # Handle specifications like "numpy>=1.0", "requests==2.0", etc.
        match = re.match(r"^([a-zA-Z0-9_.-]+)(.*)$", pkg_spec.strip())
        if match:
            pkg_name = match.group(1)
            constraint = match.group(2) if match.group(2) else ""
            return pkg_name.lower(), constraint
        return pkg_spec.lower(), ""

    def _build_install_flags(self, parsed_args):
        """Build install flags from parsed arguments"""
        flags = []

        # Constraints
        if getattr(parsed_args, "constraints", None):
            for constraint_file in parsed_args.constraints:
                flags.extend(["-c", constraint_file])

        # Editable installs (handled separately in package list)
        if getattr(parsed_args, "editables", None):
            for editable in parsed_args.editables:
                flags.extend(["-e", editable])

        # Extras
        if getattr(parsed_args, "extras", None):
            for extra in parsed_args.extras:
                flags.extend(["--extra", extra])

        if getattr(parsed_args, "all_extras", False):
            flags.append("--all-extras")

        # Upgrade options
        if getattr(parsed_args, "upgrade", False):
            flags.append("-U")

        if getattr(parsed_args, "upgrade_packages", None):
            for pkg in parsed_args.upgrade_packages:
                flags.extend(["-P", pkg])

        # Index options
        if getattr(parsed_args, "index_url", None):
            flags.extend(["-i", parsed_args.index_url])

        if getattr(parsed_args, "extra_index_urls", None):
            for url in parsed_args.extra_index_urls:
                flags.extend(["--extra-index-url", url])

        if getattr(parsed_args, "find_links", None):
            for link in parsed_args.find_links:
                flags.extend(["-f", link])

        if getattr(parsed_args, "no_index", False):
            flags.append("--no-index")

        # Installation options
        if getattr(parsed_args, "user", False):
            flags.append("--user")

        if getattr(parsed_args, "target", None):
            flags.extend(["--target", parsed_args.target])

        if getattr(parsed_args, "prefix", None):
            flags.extend(["--prefix", parsed_args.prefix])

        # Build options
        if getattr(parsed_args, "no_deps", False):
            flags.append("--no-deps")

        if getattr(parsed_args, "no_build", False):
            flags.append("--no-build")

        if getattr(parsed_args, "no_binary", None):
            for pkg in parsed_args.no_binary:
                flags.extend(["--no-binary", pkg])

        if getattr(parsed_args, "only_binary", None):
            for pkg in parsed_args.only_binary:
                flags.extend(["--only-binary", pkg])

        # Other options
        if getattr(parsed_args, "force_reinstall", False):
            flags.append("--reinstall")

        if getattr(parsed_args, "require_hashes", False):
            flags.append("--require-hashes")

        return flags

    def _is_version_compatible(self, available_version, constraint):
        """Check if available version satisfies the constraint"""
        if not constraint:
            return True

        # Simple version comparison - for a full solution, we'd use packaging.specifiers
        # This handles the most common cases
        if constraint.startswith(">="):
            required = constraint[2:].strip()
            return available_version >= required
        elif constraint.startswith("=="):
            required = constraint[2:].strip()
            return available_version == required
        elif constraint.startswith(">"):
            required = constraint[1:].strip()
            return available_version > required
        elif constraint.startswith("<="):
            required = constraint[2:].strip()
            return available_version <= required
        elif constraint.startswith("<"):
            required = constraint[1:].strip()
            return available_version < required

        # Default to compatible for complex constraints
        return True

    def pip_install(self, packages, pip_args=None, parsed_args=None):
        """Install packages with parent dependency checking"""
        if not self.current_venv:
            print(
                "Error: No active virtual environment. Please activate one first.",
                file=sys.stderr,
            )
            sys.exit(1)

        # Extract parsed arguments and build comprehensive package list
        all_packages = list(packages) if packages else []
        requirements_files = []
        editables = []
        install_flags = []

        if parsed_args:
            # Handle requirements files
            if getattr(parsed_args, "requirements", None):
                requirements_files = parsed_args.requirements

            # Handle editable installs
            if getattr(parsed_args, "editables", None):
                editables = parsed_args.editables

            # Build install flags from parsed arguments
            install_flags = self._build_install_flags(parsed_args)
        else:
            # Fallback for old-style calls (backwards compatibility)
            # For now, we'll handle requirements_files parameter as before
            if hasattr(parsed_args, "__iter__") and not isinstance(parsed_args, str):
                # If parsed_args is actually requirements_files list (old signature)
                requirements_files = parsed_args or []

        # Process requirements files
        if requirements_files:
            for req_file in requirements_files:
                try:
                    with open(req_file) as f:
                        for line in f:
                            line = line.strip()
                            # Skip empty lines and comments
                            if line and not line.startswith("#"):
                                all_packages.append(line)
                except FileNotFoundError:
                    print(
                        f"Error: Requirements file '{req_file}' not found.",
                        file=sys.stderr,
                    )
                    sys.exit(1)
                except Exception as e:
                    print(
                        f"Error reading requirements file '{req_file}': {e}",
                        file=sys.stderr,
                    )
                    sys.exit(1)

        # Add editable packages
        if editables:
            all_packages.extend(editables)

        if not all_packages:
            print("Error: No packages specified for installation.", file=sys.stderr)
            sys.exit(1)

        # Use all_packages instead of packages for the rest of the method
        packages = all_packages

        # Get packages available from parents
        parent_packages = self._get_parent_packages(self.current_venv)

        print("ðŸ” Analyzing dependencies...")

        # Get full dependency tree using dry-run
        # Build dry-run command with appropriate flags
        dry_run_args = []
        if install_flags:
            # Filter out flags that might interfere with dry-run analysis
            safe_flags = []
            skip_next = False
            for i, flag in enumerate(install_flags):
                if skip_next:
                    skip_next = False
                    continue

                # Skip flags that don't work well with dry-run dependency analysis
                if flag in ["--user", "--target", "--prefix", "--reinstall"]:
                    continue
                if flag in [
                    "-c",
                    "--constraints",
                    "-f",
                    "--find-links",
                    "-i",
                    "--index-url",
                    "--extra-index-url",
                ]:
                    safe_flags.append(flag)
                    # These flags take arguments, so skip the next item too
                    if i + 1 < len(install_flags):
                        safe_flags.append(install_flags[i + 1])
                        skip_next = True
                elif flag in ["--no-index", "--all-extras", "-U", "--upgrade"]:
                    safe_flags.append(flag)
                elif flag.startswith("--extra"):
                    safe_flags.append(flag)
                    if not flag.startswith("--extra=") and i + 1 < len(install_flags):
                        safe_flags.append(install_flags[i + 1])
                        skip_next = True
            dry_run_args = safe_flags

        dependency_tree = self._get_dependency_tree(packages, dry_run_args)

        if dependency_tree:
            print(
                f"ðŸ“‹ Found {len(dependency_tree)} total packages (including dependencies)"
            )

            # Check each package in the dependency tree
            packages_to_install = []
            skipped_packages = []
            version_conflicts = []

            # First, handle the explicitly requested packages
            explicit_packages = set()
            for pkg_spec in packages:
                pkg_name, constraint = self._parse_version_constraint(pkg_spec)
                explicit_packages.add(pkg_name)

                if pkg_name in parent_packages:
                    available_version = parent_packages[pkg_name]
                    if self._is_version_compatible(available_version, constraint):
                        print(
                            f"ðŸ“¦ Skipping '{pkg_name}' (v{available_version} from parent satisfies {constraint or 'any version'})"
                        )
                        skipped_packages.append(pkg_name)
                    else:
                        print(
                            f"âš ï¸  Parent has '{pkg_name}' v{available_version}, but need {constraint}"
                        )
                        packages_to_install.append(pkg_spec)
                        version_conflicts.append(
                            f"{pkg_name}: parent v{available_version} vs required {constraint}"
                        )
                else:
                    packages_to_install.append(pkg_spec)

            # Then handle dependencies
            for dep_name in dependency_tree:
                if dep_name in explicit_packages:
                    continue  # Already handled above

                if dep_name in parent_packages:
                    parent_version = parent_packages[dep_name]
                    print(
                        f"ðŸ“¦ Dependency '{dep_name}' (v{parent_version} available from parent)"
                    )
                    skipped_packages.append(dep_name)
                else:
                    # Add dependency to install list - we'll use --no-deps later
                    packages_to_install.append(dep_name)

            if version_conflicts:
                print("\nâš ï¸  Version conflicts detected:")
                for conflict in version_conflicts:
                    print(f"   {conflict}")
                print(
                    "   Child environment will override parent versions for these packages."
                )

        else:
            # Fallback to original logic if dry-run fails
            print("âš ï¸  Could not analyze dependencies, using basic package checking")
            packages_to_install = []
            skipped_packages = []

            for pkg_spec in packages:
                pkg_name = re.split(r"[<>=!]", pkg_spec)[0].strip().lower()

                if pkg_name in parent_packages:
                    print(
                        f"ðŸ“¦ Skipping '{pkg_name}' (v{parent_packages[pkg_name]} available from parent)"
                    )
                    skipped_packages.append(pkg_name)
                else:
                    packages_to_install.append(pkg_spec)

        if not packages_to_install:
            print(
                "âœ… All requested packages and dependencies are already available from parent environments."
            )
            return

        print(f"\nðŸ“¥ Installing {len(packages_to_install)} package(s)")
        if skipped_packages:
            print(
                f"â­ï¸  Skipped {len(skipped_packages)} package(s) available from parent"
            )

        # Build uv pip install command
        cmd = [self.uv_executable, "pip", "install"]

        # Add install flags from parsed arguments first
        if install_flags:
            cmd.extend(install_flags)

        # Handle dependency conflicts
        no_deps_from_args = "--no-deps" in install_flags
        if dependency_tree and skipped_packages and not no_deps_from_args:
            # If we skipped some dependencies, we need to install without automatic dependency resolution
            # to avoid conflicts with parent packages
            cmd.append("--no-deps")
            print("ðŸ”§ Using --no-deps to avoid conflicts with parent environment")

        # Add packages to install
        cmd.extend(packages_to_install)

        # Add any additional pip args that weren't parsed
        if pip_args:
            cmd.extend(pip_args)

        # Run the installation
        try:
            subprocess.run(cmd, check=True)
            print("âœ… Installation completed successfully.")

            if dependency_tree and skipped_packages:
                print("\nðŸ“¦ Package hierarchy summary:")
                print(f"   â€¢ Installed in child: {len(packages_to_install)} packages")
                print(f"   â€¢ Available from parent: {len(skipped_packages)} packages")

        except subprocess.CalledProcessError as e:
            print(
                f"âŒ Installation failed with exit code {e.returncode}", file=sys.stderr
            )
            sys.exit(e.returncode)

    def pip_uninstall(self, packages, pip_args=None):
        """Uninstall packages from current environment"""
        if not self.current_venv:
            print(
                "Error: No active virtual environment. Please activate one first.",
                file=sys.stderr,
            )
            sys.exit(1)

        if not packages:
            print("Error: No packages specified for uninstallation.", file=sys.stderr)
            sys.exit(1)

        # Get currently installed packages in this environment
        current_packages = self._get_installed_packages(self.current_venv)
        parent_packages = self._get_parent_packages(self.current_venv)

        packages_to_remove = []
        not_found = []
        parent_available = []

        for pkg_name in packages:
            pkg_name_lower = pkg_name.lower()

            if pkg_name_lower in current_packages:
                packages_to_remove.append(pkg_name)
                if pkg_name_lower in parent_packages:
                    parent_available.append(
                        f"{pkg_name} (v{parent_packages[pkg_name_lower]} still available from parent)"
                    )
            else:
                not_found.append(pkg_name)

        if not_found:
            print(
                f"âš ï¸  Packages not installed in current environment: {', '.join(not_found)}"
            )

        if not packages_to_remove:
            print("âŒ No packages to uninstall from current environment.")
            return

        print(
            f"ðŸ—‘ï¸  Uninstalling {len(packages_to_remove)} package(s): {', '.join(packages_to_remove)}"
        )
        if parent_available:
            print(
                "ðŸ“¦ After uninstall, these packages will still be available from parent:"
            )
            for pkg in parent_available:
                print(f"   - {pkg}")

        # Build uv pip uninstall command
        cmd = [self.uv_executable, "pip", "uninstall"] + packages_to_remove
        if pip_args:
            cmd.extend(pip_args)

        # Run the uninstallation
        try:
            subprocess.run(cmd, check=True)
            print("âœ… Uninstallation completed successfully.")
        except subprocess.CalledProcessError as e:
            print(
                f"âŒ Uninstallation failed with exit code {e.returncode}",
                file=sys.stderr,
            )
            sys.exit(e.returncode)

    def passthrough_command(self, args):
        """Pass through commands directly to uv"""
        cmd = [self.uv_executable] + args

        try:
            # Use execvp to replace the current process with uv
            # This ensures that uv gets the exact same environment and signal handling
            os.execvp(self.uv_executable, cmd)
        except OSError as e:
            print(f"âŒ Failed to execute uv: {e}", file=sys.stderr)
            sys.exit(1)


def main():
    huv = HierarchicalUV()

    # Check if this is a huv-specific command that needs special handling
    if len(sys.argv) >= 2:
        if sys.argv[1] == "venv" and "--parent" in sys.argv:
            # Handle hierarchical venv creation
            parser = argparse.ArgumentParser(
                description="Create hierarchical virtual environment",
                formatter_class=argparse.RawDescriptionHelpFormatter,
                epilog="All standard uv venv options are supported alongside --parent",
            )
            parser.add_argument("command")  # venv
            parser.add_argument("path", help="Path for the virtual environment")

            # Hierarchical option (huv-specific)
            parser.add_argument("--parent", help="Parent virtual environment path")

            # Core venv options
            parser.add_argument(
                "--no-project",
                action="store_true",
                help="Avoid discovering a project or workspace",
            )
            parser.add_argument(
                "--seed",
                action="store_true",
                help="Install seed packages (pip, setuptools, wheel)",
            )
            parser.add_argument(
                "-c",
                "--clear",
                action="store_true",
                help="Remove existing files at target path",
            )
            parser.add_argument(
                "--allow-existing",
                action="store_true",
                help="Preserve existing files at target path",
            )
            parser.add_argument(
                "--prompt", help="Alternative prompt prefix for the virtual environment"
            )
            parser.add_argument(
                "--system-site-packages",
                action="store_true",
                help="Give access to system site packages",
            )
            parser.add_argument(
                "--relocatable",
                action="store_true",
                help="Make the virtual environment relocatable",
            )

            # Python options
            parser.add_argument(
                "-p",
                "--python",
                help="Python interpreter to use for the virtual environment",
            )
            parser.add_argument(
                "--managed-python",
                action="store_true",
                help="Require use of uv-managed Python versions",
            )
            parser.add_argument(
                "--no-managed-python",
                action="store_true",
                help="Disable use of uv-managed Python versions",
            )
            parser.add_argument(
                "--no-python-downloads",
                action="store_true",
                help="Disable automatic downloads of Python",
            )

            # Index options
            parser.add_argument(
                "--index",
                action="append",
                help="URLs to use when resolving dependencies",
            )
            parser.add_argument(
                "--default-index", help="URL of the default package index"
            )
            parser.add_argument(
                "-i", "--index-url", help="URL of the Python package index (deprecated)"
            )
            parser.add_argument(
                "--extra-index-url",
                action="append",
                help="Extra URLs of package indexes (deprecated)",
            )
            parser.add_argument(
                "-f",
                "--find-links",
                action="append",
                help="Locations to search for candidate distributions",
            )
            parser.add_argument(
                "--no-index", action="store_true", help="Ignore the registry index"
            )

            # Performance and cache options
            parser.add_argument(
                "--index-strategy",
                choices=["first-index", "unsafe-first-match", "unsafe-best-match"],
                help="Strategy when resolving against multiple index URLs",
            )
            parser.add_argument(
                "--keyring-provider",
                choices=["disabled", "subprocess"],
                help="Attempt to use keyring for authentication",
            )
            parser.add_argument(
                "--exclude-newer",
                help="Limit packages to those uploaded prior to given date",
            )
            parser.add_argument(
                "--exclude-newer-package",
                action="append",
                help="Limit specific packages to older versions",
            )
            parser.add_argument(
                "--link-mode",
                choices=["clone", "copy", "hardlink", "symlink"],
                help="Method to use when installing packages from global cache",
            )
            parser.add_argument(
                "--refresh", action="store_true", help="Refresh all cached data"
            )
            parser.add_argument(
                "-n",
                "--no-cache",
                action="store_true",
                help="Avoid reading from or writing to cache",
            )
            parser.add_argument("--cache-dir", help="Path to the cache directory")
            parser.add_argument(
                "--refresh-package",
                action="append",
                help="Refresh cached data for specific packages",
            )

            args, unknown_args = parser.parse_known_args()

            # Build uv_args from parsed arguments
            uv_args = []
            if hasattr(args, "no_project") and args.no_project:
                uv_args.append("--no-project")
            if hasattr(args, "seed") and args.seed:
                uv_args.append("--seed")
            if hasattr(args, "clear") and args.clear:
                uv_args.extend(["-c"])
            if hasattr(args, "allow_existing") and args.allow_existing:
                uv_args.append("--allow-existing")
            if hasattr(args, "prompt") and args.prompt:
                uv_args.extend(["--prompt", args.prompt])
            if hasattr(args, "system_site_packages") and args.system_site_packages:
                uv_args.append("--system-site-packages")
            if hasattr(args, "relocatable") and args.relocatable:
                uv_args.append("--relocatable")

            # Python options
            if hasattr(args, "python") and args.python:
                uv_args.extend(["-p", args.python])
            if hasattr(args, "managed_python") and args.managed_python:
                uv_args.append("--managed-python")
            if hasattr(args, "no_managed_python") and args.no_managed_python:
                uv_args.append("--no-managed-python")
            if hasattr(args, "no_python_downloads") and args.no_python_downloads:
                uv_args.append("--no-python-downloads")

            # Index options
            if hasattr(args, "index") and args.index:
                for idx in args.index:
                    uv_args.extend(["--index", idx])
            if hasattr(args, "default_index") and args.default_index:
                uv_args.extend(["--default-index", args.default_index])
            if hasattr(args, "index_url") and args.index_url:
                uv_args.extend(["-i", args.index_url])
            if hasattr(args, "extra_index_url") and args.extra_index_url:
                for url in args.extra_index_url:
                    uv_args.extend(["--extra-index-url", url])
            if hasattr(args, "find_links") and args.find_links:
                for link in args.find_links:
                    uv_args.extend(["-f", link])
            if hasattr(args, "no_index") and args.no_index:
                uv_args.append("--no-index")

            # Performance options
            if hasattr(args, "index_strategy") and args.index_strategy:
                uv_args.extend(["--index-strategy", args.index_strategy])
            if hasattr(args, "keyring_provider") and args.keyring_provider:
                uv_args.extend(["--keyring-provider", args.keyring_provider])
            if hasattr(args, "exclude_newer") and args.exclude_newer:
                uv_args.extend(["--exclude-newer", args.exclude_newer])
            if hasattr(args, "exclude_newer_package") and args.exclude_newer_package:
                for pkg in args.exclude_newer_package:
                    uv_args.extend(["--exclude-newer-package", pkg])
            if hasattr(args, "link_mode") and args.link_mode:
                uv_args.extend(["--link-mode", args.link_mode])
            if hasattr(args, "refresh") and args.refresh:
                uv_args.append("--refresh")
            if hasattr(args, "no_cache") and args.no_cache:
                uv_args.append("-n")
            if hasattr(args, "cache_dir") and args.cache_dir:
                uv_args.extend(["--cache-dir", args.cache_dir])
            if hasattr(args, "refresh_package") and args.refresh_package:
                for pkg in args.refresh_package:
                    uv_args.extend(["--refresh-package", pkg])

            # Add any unknown args
            uv_args.extend(unknown_args)

            huv.create_venv(args.path, args.parent, uv_args)
            return

        elif (
            sys.argv[1] == "pip"
            and len(sys.argv) >= 3
            and sys.argv[2] in ["install", "uninstall"]
        ):
            # Handle hierarchical pip commands
            if sys.argv[2] == "install":
                parser = argparse.ArgumentParser(
                    description="Install packages with hierarchy awareness"
                )
                parser.add_argument("command")  # pip
                parser.add_argument("subcommand")  # install
                parser.add_argument("packages", nargs="*", help="Packages to install")

                # Requirements and constraints
                parser.add_argument(
                    "-r",
                    "--requirement",
                    dest="requirements",
                    action="append",
                    help="Requirements files",
                )
                parser.add_argument(
                    "-c",
                    "--constraints",
                    dest="constraints",
                    action="append",
                    help="Constraint files",
                )

                # Editable installs
                parser.add_argument(
                    "-e",
                    "--editable",
                    dest="editables",
                    action="append",
                    help="Editable packages",
                )

                # Extras
                parser.add_argument(
                    "--extra",
                    dest="extras",
                    action="append",
                    help="Include optional dependencies",
                )
                parser.add_argument(
                    "--all-extras",
                    action="store_true",
                    help="Include all optional dependencies",
                )

                # Upgrade options
                parser.add_argument(
                    "-U",
                    "--upgrade",
                    action="store_true",
                    help="Allow package upgrades",
                )
                parser.add_argument(
                    "-P",
                    "--upgrade-package",
                    dest="upgrade_packages",
                    action="append",
                    help="Allow upgrades for specific packages",
                )

                # Index options
                parser.add_argument(
                    "-i",
                    "--index-url",
                    dest="index_url",
                    help="Base URL of Python Package Index",
                )
                parser.add_argument(
                    "--extra-index-url",
                    dest="extra_index_urls",
                    action="append",
                    help="Extra URLs of package indexes",
                )
                parser.add_argument(
                    "-f",
                    "--find-links",
                    dest="find_links",
                    action="append",
                    help="Look for archives at this URL or path",
                )
                parser.add_argument(
                    "--no-index", action="store_true", help="Ignore package index"
                )

                # Installation options
                parser.add_argument(
                    "--user", action="store_true", help="Install to user directory"
                )
                parser.add_argument(
                    "--target",
                    dest="target",
                    help="Install packages into specified directory",
                )
                parser.add_argument(
                    "--prefix", dest="prefix", help="Installation prefix"
                )

                # Build options
                parser.add_argument(
                    "--no-deps",
                    action="store_true",
                    help="Don't install package dependencies",
                )
                parser.add_argument(
                    "--no-build",
                    action="store_true",
                    help="Don't build source distributions",
                )
                parser.add_argument(
                    "--no-binary",
                    dest="no_binary",
                    action="append",
                    help="Don't use pre-built wheels",
                )
                parser.add_argument(
                    "--only-binary",
                    dest="only_binary",
                    action="append",
                    help="Only use pre-built wheels",
                )

                # Other common options
                parser.add_argument(
                    "--force-reinstall",
                    "--reinstall",
                    action="store_true",
                    help="Reinstall all packages",
                )
                parser.add_argument(
                    "--require-hashes",
                    action="store_true",
                    help="Require a matching hash for each requirement",
                )

                args, unknown_args = parser.parse_known_args()
                huv.pip_install(args.packages, unknown_args, args)
                return

            elif sys.argv[2] == "uninstall":
                parser = argparse.ArgumentParser(
                    description="Uninstall packages with hierarchy awareness"
                )
                parser.add_argument("command")  # pip
                parser.add_argument("subcommand")  # uninstall
                parser.add_argument("packages", nargs="+", help="Packages to uninstall")
                args, unknown_args = parser.parse_known_args()
                huv.pip_uninstall(args.packages, unknown_args)
                return

    # For all other commands, pass through to uv
    # Remove the script name and pass everything else
    if len(sys.argv) > 1:
        huv.passthrough_command(sys.argv[1:])
    else:
        # No arguments - show uv help
        huv.passthrough_command(["--help"])


if __name__ == "__main__":
    main()

